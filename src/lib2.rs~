use rusqlite::{Connection, Result};

pub fn display_word_meanings(conn: &Connection, word: &str) -> Result<()> {
    // Modified query to include synonyms and antonyms
    let mut stmt = conn.prepare(
        r#"
        WITH current_senses AS (
            SELECT s.synsetid
            FROM words w
            JOIN senses s ON w.wordid = s.wordid
            WHERE w.lemma = ?
        )
        SELECT 
            ld.pos,
            ss.definition,
            GROUP_CONCAT(DISTINCT sm.sample, '; ') as examples,
            (
                SELECT GROUP_CONCAT(DISTINCT w2.lemma, ', ')
                FROM senses s2
                JOIN words w2 ON s2.wordid = w2.wordid
                WHERE s2.synsetid = ss.synsetid AND w2.lemma != ?
            ) as synonyms,
            (
                SELECT GROUP_CONCAT(DISTINCT w3.lemma, ', ')
                FROM semlinks sl
                JOIN linktypes lt ON sl.linkid = lt.linkid
                JOIN senses s3 ON sl.synset2id = s3.synsetid
                JOIN words w3 ON s3.wordid = w3.wordid
                WHERE sl.synset1id = ss.synsetid AND lt.name = 'antonym'
            ) as antonyms
        FROM words w
        JOIN senses s ON w.wordid = s.wordid
        JOIN synsets ss ON s.synsetid = ss.synsetid
        JOIN lexdomains ld ON ss.lexdomain = ld.lexdomainid
        LEFT JOIN samples sm ON ss.synsetid = sm.synsetid
        WHERE w.lemma = ?
        GROUP BY ss.synsetid
        ORDER BY ld.pos, s.senseid;
        "#
    )?;

    println!("\nMeanings of '{}':", word);

    let rows = stmt.query_map([word, word, word], |row| {
        Ok((
            row.get::<_, String>(0)?,  // pos
            row.get::<_, String>(1)?,  // definition
            row.get::<_, Option<String>>(2)?,  // examples
            row.get::<_, Option<String>>(3)?,  // synonyms
            row.get::<_, Option<String>>(4)?,  // antonyms
        ))
    })?;

    for row in rows {
        let (pos, definition, examples, synonyms, antonyms) = row?;
        
        // Print part of speech and definition
        let pos_symbol = match pos.as_str() {
            "n" => "(n)",
            "v" => "(v)",
            "a" | "s" => "(adj)",
            "r" => "(adv)",
            _ => "(?)",
        };
        println!("{} {}", pos_symbol, definition);

        // Print examples if they exist
        if let Some(examples_str) = examples {
            for example in examples_str.split("; ") {
                if !example.trim().is_empty() {
                    println!("      \"{}\"", example.trim().trim_matches('"'));
                }
            }
        }

        // Print synonyms if they exist
        if let Some(syns) = synonyms {
            if !syns.is_empty() {
                println!("      Synonyms: {}", syns);
            }
        }

        // Print antonyms if they exist
        if let Some(ants) = antonyms {
            if !ants.is_empty() {
                println!("      Antonyms: {}", ants);
            }
        }
    }

    Ok(())
}
